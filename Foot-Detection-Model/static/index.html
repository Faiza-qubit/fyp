<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Foot Keypoints Live</title>

  <style>
    body {
      margin: 0;
      text-align: center;
      font-family: Arial, sans-serif;
      background: #111;
      color: white;
    }

    video, canvas {
      width: 100%;
      max-width: 420px;
      border-radius: 12px;
      margin-top: 10px;
    }

    #status {
      margin: 10px;
      font-size: 14px;
      color: #00ff99;
    }
  </style>
</head>

<body>

  <h2>Live Foot Keypoints (Stable)</h2>
  <p id="status">Initializing cameraâ€¦</p>

  <video id="video" autoplay playsinline></video>
  <canvas id="canvas"></canvas>

  <script>
  const video = document.getElementById("video");
  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d");
  const statusEl = document.getElementById("status");

  const INFER_URL = "/infer";  

  let lastGoodFeet = [null, null]; // index 0 = left, index 1 = right

  // Keypoints 
  const footKeypointNames = [
    "Heel",       // 0
    "Little toe",      // 1
    "Big Toe",    // 2
    "Ankle",  // 3
    
  ];


  function getCenterX(bbox) {
    return (bbox[0] + bbox[2]) / 2;
  }

  function distance(a, b) {
    return Math.hypot(a[0] - b[0], a[1] - b[1]);
  }

  // Camera setup
  async function setupCamera() {
    const stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: "environment" }
    });
    video.srcObject = stream;

    return new Promise(resolve => {
      video.onloadedmetadata = () => {
        video.play();
        resolve();
      };
    });
  }

  // Draw feet and keypoints
  function drawFeet() {
    lastGoodFeet.forEach((det, idx) => {
      if (!det) return;

      const [x1, y1, x2, y2] = det.bbox;

      ctx.strokeStyle = idx === 0 ? "lime" : "cyan";
      ctx.lineWidth = 2.5;
      ctx.strokeRect(x1, y1, x2 - x1, y2 - y1);

      ctx.fillStyle = "white";
      ctx.font = "16px Arial";
      ctx.fillText(idx === 0 ? "Left Foot" : "Right Foot", x1, y1 - 8);

      det.keypoints.forEach(([x, y], i) => {
        if (x < 1 || y < 1) return; 

        ctx.beginPath();
        ctx.arc(x, y, 6, 0, Math.PI * 2);
        ctx.fillStyle = idx === 0 ? "red" : "orange";
        ctx.fill();

        const name = footKeypointNames[i] || "";
        const label = name ? `${i} ${name}` : `${i}`;

        ctx.fillStyle = "yellow";
        ctx.font = "8px Arial";
        ctx.fillText(label, x + 7, y + 4);
      });
    });
  }


  function updateFeet(detections) {
    if (detections.length === 0) return;

    
    detections.sort((a, b) => getCenterX(a.bbox) - getCenterX(b.bbox));

    
    const assigned = [false, false];

    detections.forEach(det => {
      const cx = getCenterX(det.bbox);

    
      if (!assigned[0] && (lastGoodFeet[0] === null || cx < getCenterX(lastGoodFeet[0].bbox) + 80)) {
        lastGoodFeet[0] = det;
        assigned[0] = true;
        return;
      }

   
      if (!assigned[1] && (lastGoodFeet[1] === null || cx > getCenterX(lastGoodFeet[1].bbox) - 80)) {
        lastGoodFeet[1] = det;
        assigned[1] = true;
        return;
      }

      
      let bestIdx = -1;
      let bestDist = Infinity;
      const center = [cx, (det.bbox[1] + det.bbox[3]) / 2];

      lastGoodFeet.forEach((old, i) => {
        if (!old) return;
        const oldCenter = [getCenterX(old.bbox), (old.bbox[1] + old.bbox[3]) / 2];
        const d = distance(center, oldCenter);
        if (d < bestDist) {
          bestDist = d;
          bestIdx = i;
        }
      });

      if (bestIdx !== -1 && bestDist < 120) { 
        lastGoodFeet[bestIdx] = det;
      } else if (lastGoodFeet[0] === null) {
        lastGoodFeet[0] = det;
      } else if (lastGoodFeet[1] === null) {
        lastGoodFeet[1] = det;
      }
    });

    
    if (lastGoodFeet[0] && lastGoodFeet[1]) {
      if (getCenterX(lastGoodFeet[0].bbox) > getCenterX(lastGoodFeet[1].bbox)) {
        [lastGoodFeet[0], lastGoodFeet[1]] = [lastGoodFeet[1], lastGoodFeet[0]];
      }
    }
  }

  
  async function detectAndDraw() {
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;

    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
    drawFeet();

    try {
      const blob = await new Promise(r => canvas.toBlob(r, "image/jpeg", 0.92));
      const formData = new FormData();
      formData.append("file", blob, "frame.jpg");

      const res = await fetch(INFER_URL, { method: "POST", body: formData });

      if (!res.ok) throw new Error(`HTTP ${res.status}`);

      const data = await res.json();

      const detections = data.detections
        .filter(d => d.confidence >= 0.7)  
        .slice(0, 2);

      if (detections.length > 0) {
        updateFeet(detections);
        const count = lastGoodFeet.filter(f => f !== null).length;
        statusEl.textContent = `Tracking ${count} foot/feet`;
      } else {
        statusEl.textContent = "No feet detected holding last position";
      }

    } catch (e) {
      console.error(e);
      statusEl.textContent = "Inference error check console";
    }

    requestAnimationFrame(detectAndDraw);
  }

  // Start
  setupCamera()
    .then(() => {
      statusEl.textContent = "Camera ready detecting...";
      detectAndDraw();
    })
    .catch(err => {
      statusEl.textContent = "Camera error: " + err.message;
      console.error(err);
    });
</script>


</body>
</html>